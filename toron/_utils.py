"""Utility functions and classes for the Toron project.

This sub-module contains code that is used elsewhere in Toron to
handle data, raise exceptions, and issue warnings.

NOTE: Ideally, this module should not import code from within Toron
itself--it should only import from the Python Standard Library or
indepdendent, third-party packages. That said, Toron's compatibility
modules (like `_typing`) are treated as if they are part of the
Standard Library and may be imported.
"""

from itertools import chain
from ._typing import (
    Callable,
    Generator,
    Iterable,
    Mapping,
    Optional,
    Sequence,
    Union,
)


class ToronError(Exception):
    """Error in Toron usage or invocation."""


class ToronWarning(UserWarning):
    """Base class for warnings generated by Toron."""


def _data_to_dict_rows(
    data: Union[Iterable[Mapping], Iterable[Sequence]],
    columns: Optional[Sequence[str]] = None,
) -> Iterable[Mapping]:
    """Normalize data as an iterator of dictionary rows."""
    iter_data = iter(data)
    first_element = next(iter_data)
    if isinstance(first_element, Sequence):
        if not columns:
            columns = first_element
        else:
            iter_data = chain([first_element], iter_data)
        dict_rows = (dict(zip(columns, row)) for row in iter_data)
    elif isinstance(first_element, Mapping):
        dict_rows = chain([first_element], iter_data)  # type: ignore [assignment]
    else:
        msg = (f'data must contain mappings or sequences, '
               f'got type {type(first_element)}')
        raise TypeError(msg)
    return dict_rows


def wide_to_long(
    data: Union[Iterable[Mapping], Iterable[Sequence]],
    value_vars: Sequence[str],
    make_attrs: Union[str, Callable[[str], Mapping[str, str]]] = 'variable',
    *,
    value_name: str = 'value',
    columns: Optional[Sequence[str]] = None,
) -> Generator[Mapping, None, None]:
    """A generator function to unpivot data from wide to long format
    and yield dictionary rows.

    Parameters
    ----------

    data : iterable of mappings (dict) or sequences
        Wide-format data.
    value_vars : sequence of str
        Column(s) to unpivot.
    make_attrs : callable or str, default 'variable'
        Function or string used to make attribute item(s).
    value_name : str, default 'value'
        Name to use for the 'value' column.
    columns : sequence of str, optional
        Column names to use if data is a sequence with no header row.

    Returns
    -------

    Generator
        Unpivoted dictionary rows.

    Examples
    --------

    Use variable as a single attribute item:

    .. code-block::

        >>> from toron import wide_to_long
        >>> wide_data = [
        ...     ('A', 'B', 'C'),
        ...     ('a', 1,   2),
        ...     ('b', 3,   4),
        ...     ('c', 5,   6),
        ... ]

    .. code-block::

        >>> long_data = wide_to_long(wide_data, value_vars=['B', 'C'])
        >>> list(long_data)
        [{'A': 'a', 'variable': 'B', 'value': 1},
         {'A': 'a', 'variable': 'C', 'value': 2},
         {'A': 'b', 'variable': 'B', 'value': 3},
         {'A': 'b', 'variable': 'C', 'value': 4},
         {'A': 'c', 'variable': 'B', 'value': 5},
         {'A': 'c', 'variable': 'C', 'value': 6}]

    .. code-block::

        >>> long_data = wide_to_long(wide_data, value_vars=['B', 'C'], make_attrs='altname')
        >>> list(long_data)
        [{'A': 'a', 'altname': 'B', 'value': 1},
         {'A': 'a', 'altname': 'C', 'value': 2},
         {'A': 'b', 'altname': 'B', 'value': 3},
         {'A': 'b', 'altname': 'C', 'value': 4},
         {'A': 'c', 'altname': 'B', 'value': 5},
         {'A': 'c', 'altname': 'C', 'value': 6}]
        >>>

    Transform variables into multiple attribute items (with a
    function):

    .. code-block::

        >>> from toron import wide_to_long
        >>> wide_data = [
        ...     ('A', 'B1970', 'C1980', 'D'),
        ...     ('a', 10,      20,      30),
        ...     ('b', 40,      50,      60),
        ...     ('c', 70,      80,      90),
        ... ]

    .. code-block::

        >>> def make_attrs(var):
        ...     return {'letter': var[:1], 'year': var[1:]}
        ...

    .. code-block::

        >>> long_data = wide_to_long(wide_data, ['B1970', 'C1980', 'D'], make_attrs)
        >>> list(long_data)
        [{'A': 'a', 'letter': 'B', 'year': '1970', 'value': 10},
         {'A': 'a', 'letter': 'C', 'year': '1980', 'value': 20},
         {'A': 'a', 'letter': 'D', 'year': '',     'value': 30},
         {'A': 'b', 'letter': 'B', 'year': '1970', 'value': 40},
         {'A': 'b', 'letter': 'C', 'year': '1980', 'value': 50},
         {'A': 'b', 'letter': 'D', 'year': '',     'value': 60},
         {'A': 'c', 'letter': 'B', 'year': '1970', 'value': 70},
         {'A': 'c', 'letter': 'C', 'year': '1980', 'value': 80},
         {'A': 'c', 'letter': 'D', 'year': '',     'value': 90}]
    """
    attrs_func: Callable[[str], Mapping[str, str]]
    if isinstance(make_attrs, str):
        attrs_func = lambda x: {make_attrs: x}  # type: ignore [dict-item]
    elif callable(make_attrs):
        attrs_func = make_attrs
    else:
        cls_name = make_attrs.__class__.__name__
        raise TypeError(f'make_attrs type unsupported: {cls_name}')

    dict_rows = _data_to_dict_rows(data, columns)

    for input_row in dict_rows:
        other_vars_dict = {k: v for k, v in input_row.items() if k not in value_vars}
        for var in value_vars:
            try:
                value = input_row[var]
            except KeyError:
                msg = f'{var!r} not in {tuple(input_row.keys())!r}'
                raise KeyError(msg) from None

            if value is None or value == '':
                continue

            output_row = dict(attrs_func(var))

            collisions = output_row.keys() & other_vars_dict.keys()
            if collisions:
                import warnings
                formatted = ', '.join(repr(k) for k in collisions)
                msg = f'attributes cannot use the same names as other columns: {formatted}'
                warnings.warn(msg, category=ToronWarning, stacklevel=2)

            output_row.update(other_vars_dict)
            output_row[value_name] = value
            yield output_row

