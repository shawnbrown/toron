"""Stand-alone utility functions and classes for the Toron project.

This sub-module contains data handling functions, exception classes,
and warning classes.

NOTE: Ideally, this module should not import any other modules from
within Toron itself--it should only import packages from the Python
Standard Library. That said, Toron's compatibility modules (like
`_typing`) are treated as if they are part of the Standard Library
and can be imported.
"""

from itertools import chain
from ._typing import (
    Callable,
    Generator,
    Iterable,
    Mapping,
    Optional,
    Sequence,
    Union,
)


class ToronError(Exception):
    """Error in Toron usage or invocation."""


class ToronWarning(UserWarning):
    """Base class for warnings generated by Toron."""


def _data_to_dict_rows(
    data: Union[Iterable[Mapping], Iterable[Sequence]],
    columns: Optional[Sequence[str]] = None,
) -> Iterable[Mapping]:
    """Normalize data as an iterator of dictionary rows."""
    iter_data = iter(data)
    first_element = next(iter_data)
    if isinstance(first_element, Sequence):
        if not columns:
            columns = first_element
        else:
            iter_data = chain([first_element], iter_data)
        dict_rows = (dict(zip(columns, row)) for row in iter_data)
    elif isinstance(first_element, Mapping):
        dict_rows = chain([first_element], iter_data)  # type: ignore [assignment]
    else:
        msg = (f'data must contain mappings or sequences, '
               f'got type {type(first_element)}')
        raise TypeError(msg)
    return dict_rows


def wide_to_long(
    data: Union[Iterable[Mapping], Iterable[Sequence]],
    value_vars: Sequence[str],
    make_attrs: Union[str, Callable[[str], Mapping[str, str]]] = 'variable',
    *,
    value_name: str = 'value',
    columns: Optional[Sequence[str]] = None,
) -> Generator[Mapping, None, None]:
    """A generator to unpivot data from wide to long format and yield
    dictionary rows.
    """
    attrs_func: Callable[[str], Mapping[str, str]]
    if isinstance(make_attrs, str):
        attrs_func = lambda x: {make_attrs: x}  # type: ignore [dict-item]
    elif callable(make_attrs):
        attrs_func = make_attrs
    else:
        cls_name = make_attrs.__class__.__name__
        raise TypeError(f'make_attrs type unsupported: {cls_name}')

    dict_rows = _data_to_dict_rows(data, columns)

    for old_row in dict_rows:
        other_vars_dict = {k: v for k, v in old_row.items() if k not in value_vars}
        for var in value_vars:
            value = old_row[var]
            if value is None or value == '':
                continue

            new_row = dict(attrs_func(var))

            collisions = new_row.keys() & other_vars_dict.keys()
            if collisions:
                import warnings
                formatted = ', '.join(repr(k) for k in collisions)
                msg = f'attributes cannot use the same names as other columns: {formatted}'
                warnings.warn(msg, category=ToronWarning, stacklevel=2)

            new_row.update(other_vars_dict)
            new_row[value_name] = value
            yield new_row

